import numpy as np
# -*- coding: utf-8 -*-
"""ProblemasCEC2010.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10QoUIiAuLHltKUrmbnFhoWT5kMP_bD-a

## C01
"""


class ProblemaC01:
    def __init__(self, offset):
        self.tolerance = 1e-4
        self.offset = np.asarray(offset, dtype=float)
        self.D = len(self.offset)
        self.lower_bounds = np.full(self.D, 0.0)
        self.upper_bounds = np.full(self.D, 10.0)

    def get_limites(self):
        return self.lower_bounds, self.upper_bounds

    def evaluate(self, individuo):
        self.x = np.asarray(individuo, dtype=float)
        self.z = self.x - self.offset
        fitness = self.aptitud()
        suma_violaciones = self.sumar_violation()

        return fitness, suma_violaciones

    def aptitud(self):
        cos2 = np.cos(self.z) ** 2
        cos4 = np.cos(self.z) ** 4
        numerador = np.abs(np.sum(cos4) - 2 * np.prod(cos2))
        denominador = np.sqrt(np.sum(np.arange(1, self.D + 1) * self.z ** 2))
        if denominador < self.tolerance:
            return 0.0
        return - (numerador / denominador)

    def g1(self):
        return 0.75 - np.prod(self.z)

    def g2(self):
        return np.sum(self.z) - 7.5 * self.D

    def sumar_violation(self):
        viol_g1 = max(0.0, self.g1())
        viol_g2 = max(0.0, self.g2())
        return viol_g1 + viol_g2
"""## C02"""

class ProblemaC02:
    def __init__(self, offset):
        self.tolerance = 1e-4
        self.offset = np.asarray(offset, dtype=float)
        self.D = len(self.offset)
        self.lower_bounds = np.full(self.D, -5.12)
        self.upper_bounds = np.full(self.D,  5.12)

    def get_limites(self):
        return self.lower_bounds, self.upper_bounds

    def evaluate(self, individuo):
        self.x = np.asarray(individuo, dtype=float)
        self.z = self.x - self.offset
        self.y = self.z - 0.5
        fitness = self.aptitud()
        suma_violaciones = self.sumar_violation()

        return fitness, suma_violaciones

    def aptitud(self):
        return np.max(self.z)

    def g1(self):
        restriccion = self.z**2 - 10 * np.cos(2 * np.pi * self.z) + 10
        return 10 - (1 / self.D) * np.sum(restriccion)

    def g2(self):
        restriccion = self.z**2 - 10 * np.cos(2 * np.pi * self.z) + 10
        return (1 / self.D) * np.sum(restriccion) - 15

    def h1(self):
        restriccion = self.y**2 - 10 * np.cos(2 * np.pi * self.y) + 10
        return (1 / self.D) * np.sum(restriccion) - 20

    def sumar_violation(self):
        v1 = max(0.0, self.g1())
        v2 = max(0.0, self.g2())
        v3 = max(0.0, abs(self.h1()) - self.tolerance)

        return v1 + v2 + v3

"""## C03"""

class ProblemaC03:
    def __init__(self, offset):
        self.tolerance = 1e-4
        self.offset = np.asarray(offset, dtype=float)
        self.D = len(self.offset)
        self.lower_bounds = np.full(self.D, -1000.0)
        self.upper_bounds = np.full(self.D,  1000.0)

    def get_limites(self):
        return self.lower_bounds, self.upper_bounds

    def evaluate(self, individuo):
        self.x = np.asarray(individuo, dtype=float)
        self.z = self.x - self.offset
        fitness = self.aptitud()
        suma_violaciones = self.sumar_violation()

        return fitness, suma_violaciones

    def aptitud(self):
        term1 = 100 * (self.z[:-1]**2 - self.z[1:])**2
        term2 = (self.z[:-1] - 1)**2
        return np.sum(term1 + term2)

    def h1(self):
        violation = np.abs(np.sum((self.z[:-1] - self.z[1:])**2))
        return violation

    def sumar_violation(self):
        viol_h = max(0.0, abs(self.h1()) - self.tolerance)

        return viol_h

"""## C04"""

class ProblemaC04:
    def __init__(self, offset):
        # Tolerancia para igualdad h
        self.tolerance = 1e-4
        # Offset y dimensión se fijan al llamar a 'limites'
        self.offset = np.asarray(offset, dtype=float)
        self.D = len(self.offset)
        self.lower_bounds = np.full(self.D, -50.0)
        self.upper_bounds = np.full(self.D,  50.0)

    def get_limites(self):
        return self.lower_bounds, self.upper_bounds

    def evaluate(self, individuo):
        self.x = np.asarray(individuo, dtype=float)
        self.z = self.x - self.offset
        fitness = self.aptitud()
        suma_violaciones = self.suma_violation()
        return fitness, suma_violaciones

    def aptitud(self):
        return np.max(self.z)

    def h1(self):
        return np.sum(self.z * np.cos(np.sqrt(np.abs(self.z)))) / self.D

    def h2(self):
        upper = int(self.D / 2) - 1
        diffs = self.z[:upper] - self.z[1:upper+1]
        return np.sum(diffs**2)

    def h3(self):
        if self.D < 4:
            return 0.0
        start = int(self.D / 2)
        diffs = self.z[start:-1]**2 - self.z[start+1:]
        return np.sum(diffs**2)

    def h4(self):
        return np.sum(self.z)

    def suma_violation(self):
        v1 = max(0, (abs(self.h1()) - self.tolerance))
        v2 = max(0, (abs(self.h2()) - self.tolerance))
        v3 = max(0, (abs(self.h3()) - self.tolerance))
        v4 = max(0, (abs(self.h4()) - self.tolerance))

        return v1 + v2 + v3 + v4

"""## C05"""

class ProblemaC05:
    def __init__(self, offset):
        # Tolerancia para las igualdades
        self.tolerance   = 1e-4
        self.offset      = np.asarray(offset, dtype=float)
        self.D           = len(self.offset)
        self.lower_bounds = np.full(self.D, -600.0)
        self.upper_bounds = np.full(self.D,  600.0)

    def get_limites(self):
        """Devuelve los límites inferiores y superiores."""
        return self.lower_bounds, self.upper_bounds

    def evaluate(self, individuo):
        self.x = np.asarray(individuo, dtype=float)
        self.z = self.x - self.offset

        fitness            = self.aptitud()
        suma_violaciones   = self.sumar_violation()
        return fitness, suma_violaciones

    def aptitud(self):
        # f(x) = max(z)
        return np.max(self.z)

    def h1(self):
        # h1(x) = (1/D) * Σ [ -z_i * sin(√|z_i| ) ] = 0
        return np.sum(-self.z * np.sin(np.sqrt(np.abs(self.z)))) / self.D

    def h2(self):
        # h2(x) = (1/D) * Σ [ -z_i * cos(0.5 √|z_i|) ] = 0
        return np.sum(-self.z * np.cos(0.5 * np.sqrt(np.abs(self.z)))) / self.D

    def sumar_violation(self):
        v1 = max(0.0, abs(self.h1()) - self.tolerance)
        v2 = max(0.0, abs(self.h2()) - self.tolerance)
        return v1 + v2

"""## C06"""

class ProblemaC06:
    def __init__(self, offset):
        self.tolerance = 1e-4
        self.offset = np.asarray(offset, dtype=float)
        self.D = len(self.offset)
        self.lower_bounds = np.full(self.D, -600)
        self.upper_bounds = np.full(self.D,  600)
        self.m = self.generar_m(42)

    def get_limites(self):
        return self.lower_bounds, self.upper_bounds

    def generar_m(self, seed=None):
        if seed:
            np.random.seed(seed)
        A = np.random.randn(self.D, self.D)
        Q, _ = np.linalg.qr(A)
        return Q

    def evaluate(self, individuo):
        self.x = np.asarray(individuo, dtype=float)
        self.z = self.x - self.offset
        self.y = (self.x + 483.6106156535 - self.offset) * self.m - 483.6106156535
        fitness = self.aptitud()
        suma_violaciones = self.sumar_violation()

        return fitness, suma_violaciones

    def aptitud(self):
        return np.max(self.z)

    def h1(self):
        restriccion = -self.y * np.sin(np.sqrt(np.abs(self.y)))
        return (1 / self.D) * np.sum(restriccion)

    def h2(self):
        restriccion = -self.y * np.cos(0.5 * np.sqrt(np.abs(self.y)))
        return (1 / self.D) * np.sum(restriccion)

    def sumar_violation(self):
        v1 = max(0.0, (abs(self.h1()) - self.tolerance))
        v2 = max(0.0, (abs(self.h2()) - self.tolerance))

        return v1 + v2

"""## C07"""

class ProblemaC07:
    def __init__(self, offset):
        self.tolerance = 1e-4
        self.offset = np.asarray(offset, dtype=float)
        self.D = len(self.offset)
        self.lower_bounds = np.full(self.D, -140.0)
        self.upper_bounds = np.full(self.D,  140.0)

    def get_limites(self):
        return self.lower_bounds, self.upper_bounds

    def evaluate(self, individuo):
        self.x = np.asarray(individuo, dtype=float)
        self.z = self.x + 1 - self.offset
        self.y = self.x - self.offset
        fitness = self.aptitud()
        suma_violaciones = self.sumar_violation()

        return fitness, suma_violaciones

    def aptitud(self):
        term1 = 100 * (self.z[:-1]**2 - self.z[1:])**2
        term2 = (self.z[:-1] - 1)**2
        return np.sum(term1 + term2)

    def g1(self):
        term1 = np.exp(-0.1 * np.sqrt(np.sum(self.y**2) / self.D))
        term2 = 3 * np.exp(np.sum(np.cos(0.1 * self.y)) / self.D)

        return 0.5 - term1 - term2 + np.exp(1)

    def sumar_violation(self):
        viol_g= max(0.0, self.g1())

        return viol_g

"""## C08"""

class ProblemaC08:
    def __init__(self, offset):
        self.tolerance = 1e-4
        self.offset = np.asarray(offset, dtype=float)
        self.D = len(self.offset)
        self.lower_bounds = np.full(self.D, -140)
        self.upper_bounds = np.full(self.D,  140)
        self.m = self.generar_m(42)

    def get_limites(self):
        return self.lower_bounds, self.upper_bounds

    def generar_m(self, seed=None):
        if seed:
            np.random.seed(seed)
        A = np.random.randn(self.D, self.D)
        Q, _ = np.linalg.qr(A)
        return Q

    def evaluate(self, individuo):
        self.x = np.asarray(individuo, dtype=float)
        self.z = self.x + 1 - self.offset
        self.y = (self.x - self.offset) @ self.m
        fitness = self.aptitud()
        suma_violaciones = self.sumar_violation()

        return fitness, suma_violaciones

    def aptitud(self):
        term1 = 100 * (self.z[:-1]**2 - self.z[1:])**2
        term2 = (self.z[:-1] - 1)**2
        return np.sum(term1 + term2)

    def g1(self):
        term1 = 0.5 - np.exp(-0.1 * np.sqrt(1 / self.D * np.sum(self.y**2)))
        term2 = 3 - np.exp(1 / self.D * np.sum(np.cos(0.1 * self.y)))
        return term1 - term2 + np.exp(1)

    def sumar_violation(self):
        v1 = max(0.0, self.g1())

        return v1

"""## C09"""

class ProblemaC09:
    def __init__(self, offset):
        # Tolerancia para la igualdad
        self.tolerance   = 1e-4
        self.offset      = np.asarray(offset, dtype=float)
        self.D           = len(self.offset)
        self.lower_bounds = np.full(self.D, -500.0)
        self.upper_bounds = np.full(self.D,  500.0)

    def get_limites(self):
        """Devuelve los límites inferiores y superiores."""
        return self.lower_bounds, self.upper_bounds

    def evaluate(self, individuo):
        self.x = np.asarray(individuo, dtype=float)
        # z = x + 1 – offset,  y = x – offset
        self.z = self.x + 1.0 - self.offset
        self.y = self.x - self.offset

        fitness          = self.aptitud()
        suma_violaciones = self.sumar_violation()
        return fitness, suma_violaciones

    def aptitud(self):
        # f(x) = Σ_{i=1 to D-1} [ 100 ( z_i^2 – z_{i+1} )^2 + ( z_i – 1 )^2 ]
        diffs = self.z[:-1]**2 - self.z[1:]
        return np.sum(100.0 * diffs**2 + (self.z[:-1] - 1.0)**2)

    def h1(self):
        # h(x) = Σ y_i sin(√|y_i|) = 0
        return np.sum(self.y * np.sin(np.sqrt(np.abs(self.y))))

    def sumar_violation(self):
        return max(0.0, abs(self.h1()) - self.tolerance)

"""## C10"""

class ProblemaC10:
    def __init__(self, offset):
        self.tolerance = 1e-4
        self.offset = np.asarray(offset, dtype=float)
        self.D = len(self.offset)
        self.lower_bounds = np.full(self.D, -500.0)
        self.upper_bounds = np.full(self.D, 500.0)
        self.m = self.generar_m(seed=42)

    def get_limites(self):
        return self.lower_bounds, self.upper_bounds

    def generar_m(self, seed=None):
        if seed:
            np.random.seed(seed)
        A = np.random.randn(self.D, self.D)
        Q, _ = np.linalg.qr(A)
        return Q

    def evaluate(self, individuo):
        self.x = np.asarray(individuo, dtype=float)
        if self.x.shape != self.offset.shape:
            raise ValueError(
                f"Dimensionalidad de individuo ({len(self.x)}) "
                f"no coincide con offset ({len(self.offset)})"
            )
        self.z = self.x + 1 - self.offset
        self.y = (self.x - self.offset) @ self.m
        fitness = self.aptitud()
        suma_violaciones = self.sumar_violation()
        return fitness, suma_violaciones

    def aptitud(self):
        term1 = 100 * (self.z[:-1]**2 - self.z[1:])**2
        term2 = (self.z[:-1] - 1)**2
        return np.sum(term1 + term2)

    def h1(self):
        violation = np.sum(self.y * np.sin(np.sqrt(np.abs(self.y))))
        return violation

    def sumar_violation(self):
        viol_h1 = max(0.0, abs(self.h1()) - self.tolerance)
        return viol_h1

class ProblemaC11:
    def __init__(self, offset):
        self.tolerance = 1e-4
        self.offset = np.asarray(offset, dtype=float)
        self.D = len(self.offset)
        self.lower_bounds = np.full(self.D, -100.0)
        self.upper_bounds = np.full(self.D, 100.0)
        self.m = self.generar_m(seed=42)

    def get_limites(self):
        return self.lower_bounds, self.upper_bounds

    def generar_m(self, seed=None):
        if seed is not None:
            np.random.seed(seed)
        A = np.random.randn(self.D, self.D)
        Q, _ = np.linalg.qr(A)
        return Q

    def evaluate(self, individuo):
        self.x = np.asarray(individuo, dtype=float)
        if self.x.shape != self.offset.shape:
            raise ValueError(
                f"Dimensionalidad de individuo ({len(self.x)}) "
                f"no coincide con offset ({len(self.offset)})"
            )
        self.z = (self.x - self.offset) @ self.m
        self.y = self.x + 1 - self.offset
        fitness = self.aptitud()
        suma_violaciones = self.sumar_violation()
        return fitness, suma_violaciones

    def aptitud(self):
        return np.mean(-self.z * np.cos(2 * np.sqrt(np.abs(self.z))))

    def h1(self):
        term1 = 100 * (self.y[:-1]**2 - self.y[1:])**2
        term2 = (self.y[:-1] - 1)**2
        return np.sum(term1 + term2)

    def sumar_violation(self):
        viol_h1 = max(0.0, abs(self.h1()) - self.tolerance)
        return viol_h1

"""## C12"""

class ProblemaC12:
    def __init__(self, offset):
        # Tolerancia para igualdad h
        self.tolerance = 1e-4
        # Offset y dimensión se fijan al llamar a 'limites'
        self.offset = np.asarray(offset, dtype=float)
        self.D = len(self.offset)
        self.lower_bounds = np.full(self.D, -1000.0)
        self.upper_bounds = np.full(self.D,  1000.0)

    def get_limites(self):
        return self.lower_bounds, self.upper_bounds

    def evaluate(self, individuo):
        if self.offset is None or self.D is None:
            raise ValueError("Antes de evaluar, debes llamar a 'limites(offset)' para fijar el offset.")

        x = np.asarray(individuo, dtype=float)
        if x.shape != self.offset.shape:
            raise ValueError(
                f"Dimensionalidad de individuo ({len(x)}) "
                f"no coincide con offset ({len(self.offset)})"
            )
        z = x - self.offset

        fitness = self.aptitud(z)
        total_violation = self.sumar_violation(z)
        return fitness, total_violation

    def aptitud(self, z):
        """Función objetivo (aptitud) del problema C12."""
        inner = z * np.sin(np.sqrt(np.abs(z)))
        return np.sum(inner)

    def h(self, z):
        """Restricción de igualdad (relajada con tolerancia)."""
        diffs = z[:-1]**2 - z[1:]
        return np.sum(diffs**2)

    def g(self, z):
        """Restricción de desigualdad."""
        inner = z - 100 * np.cos(0.1 * z) + 10
        return np.sum(inner)

    def sumar_violation(self, z):
        """Calcula la violación total de las restricciones."""
        h_val = self.h(z)
        g_val = self.g(z)

        viol_h = max(0.0, abs(h_val) - self.tolerance)
        viol_g = max(0.0, g_val)

        return viol_h + viol_g

"""## C13"""

class ProblemaC13:
    def __init__(self, offset):
        self.tolerance = 1e-4
        self.offset = np.asarray(offset, dtype=float)
        self.D = len(self.offset)
        self.lower_bounds = np.full(self.D, -500.0)
        self.upper_bounds = np.full(self.D,  500.0)

    def get_limites(self):
        return self.lower_bounds, self.upper_bounds

    def evaluate(self, individuo):
        self.x = np.asarray(individuo, dtype=float)
        self.z = self.x - self.offset
        fitness = self.aptitud()
        suma_violaciones = self.sumar_violation()
        return fitness, suma_violaciones

    def aptitud(self):
        return np.mean(-self.z * np.sin(np.sqrt(np.abs(self.z))))

    def g1(self):
        return -50 + (1 / (100 * self.D)) * np.sum(self.z**2)

    def g2(self):
        return (50 / self.D) * np.sum(np.sin(np.abs(self.z) / 50)) - np.pi

    def g3(self):
        sum_term = np.sum(self.z**2) / 4000
        prod_term = np.prod(np.cos(self.z / np.sqrt(np.arange(1, self.D + 1))))
        return 75 - 50 * (sum_term - prod_term + 1)

    def sumar_violation(self):
        g1_val = self.g1()
        g2_val = self.g2()
        g3_val = self.g3()

        viol_g1 = max(0.0, g1_val)
        viol_g2 = max(0.0, g2_val)
        viol_g3 = max(0.0, g3_val)

        return viol_g1 + viol_g2 + viol_g3

"""## C14"""
class ProblemaC14:
    def __init__(self,offset):
        self.tolerance = 1e-4
        self.offset = np.asarray(offset, dtype=float)
        self.D = len(self.offset)
        self.lower_bounds = np.full(self.D, -1000.0)
        self.upper_bounds = np.full(self.D,  1000.0)

    def get_limites(self):
        return self.lower_bounds, self.upper_bounds

    def evaluate(self, individuo):
        x = np.asarray(individuo, dtype=float)
        z = x + 1 - self.offset
        y = x - self.offset
        fitness = self.aptitud(z)
        suma_violaciones = self.sumar_violation(y)
        return fitness, suma_violaciones

    def aptitud(self, z):
        return np.sum(100 * (z[:-1]**2 - z[1:])**2 + (z[:-1] - 1)**2)

    def g1(self, y):
        return np.sum(-y * np.cos(np.sqrt(np.abs(y)))) - self.D

    def g2(self, y):
        return np.sum(y * np.cos(np.sqrt(np.abs(y)))) - self.D

    def g3(self, y):
        return np.sum(y * np.sin(np.sqrt(np.abs(y)))) - 10 * self.D

    def sumar_violation(self, y):
        v1 = max(0.0, self.g1(y))
        v2 = max(0.0, self.g2(y))
        v3 = max(0.0, self.g3(y))
        return v1 + v2 + v3

"""## C15"""

class ProblemaC15:
    def __init__(self, offset):
        self.tolerance = 1e-4
        self.offset = np.asarray(offset, dtype=float)
        self.D = len(self.offset)
        self.lower_bounds = np.full(self.D, -1000.0)
        self.upper_bounds = np.full(self.D,  1000.0)
        self.m = self.generar_m(42)

    def get_limites(self):
        return self.lower_bounds, self.upper_bounds

    def generar_m(self, seed=None):
        if seed:
            np.random.seed(seed)
        A = np.random.randn(self.D, self.D)
        Q, _ = np.linalg.qr(A)
        return Q

    def evaluate(self, individuo):
        self.x = np.asarray(individuo, dtype=float)
        self.z = self.x + 1 - self.offset
        self.y = (self.x - self.offset) @ self.m
        fitness = self.aptitud()
        suma_violaciones = self.sumar_violation()
        return fitness, suma_violaciones

    def aptitud(self):
        term1 = 100.0 * (self.z[:-1]**2 - self.z[1:])**2
        term2 = (self.z[:-1] - 1)**2
        return np.sum(term1 + term2)

    def g1(self):
        return np.sum(-self.y * np.cos(np.sqrt(np.abs(self.y)))) - self.D

    def g2(self):
        return np.sum(self.y * np.cos(np.sqrt(np.abs(self.y)))) - self.D

    def g3(self):
        return np.sum(self.y * np.sin(np.sqrt(np.abs(self.y)))) - 10 * self.D

    def sumar_violation(self):
        v1 = max(0, self.g1())
        v2 = max(0, self.g2())
        v3 = max(0, self.g3())
        return v1 + v2 + v3

"""## C16"""

class ProblemaC16:
    def __init__(self, offset):
        self.tolerance = 1e-4
        self.offset = np.asarray(offset, dtype=float)
        self.D = len(self.offset)
        self.lower_bounds = np.full(self.D, -10.0)
        self.upper_bounds = np.full(self.D,  10.0)

    def get_limites(self):
        return self.lower_bounds, self.upper_bounds

    def evaluate(self, individuo):
        self.x = np.asarray(individuo, dtype=float)
        self.z = self.x - self.offset
        fitness = self.aptitud()
        suma_violaciones = self.suma_violation()
        return fitness, suma_violaciones

    def aptitud(self):
        sum_term = np.sum(self.z**2) / 4000.0
        prod_term = np.prod(np.cos(self.z / np.sqrt(np.arange(1, self.D + 1))))
        return sum_term - prod_term + 1

    def g1(self):
        return np.sum(self.z**2 - 100 * np.cos(np.pi * self.z) + 10)

    def g2(self):
        return np.prod(self.z)

    def h1(self):
        return np.sum(self.z * np.sin(np.sqrt(np.abs(self.z))))

    def h2(self):
        return np.sum(-self.z * np.sin(np.sqrt(np.abs(self.z))))


    def suma_violation(self):
        v_g1 = max(0, self.g1())
        v_g2 = max(0, self.g2())
        v_h1 = max(0, abs(self.h1()) - self.tolerance)
        v_h2 = max(0, abs(self.h2()) - self.tolerance)
        return v_g1 + v_g2 + v_h1 + v_h2

"""## C17"""

class ProblemaC17:
    def __init__(self, offset):
        self.tolerance = 1e-4
        self.offset = np.asarray(offset, dtype=float)
        self.D = len(self.offset)
        self.lower_bounds = np.full(self.D, -10.0)
        self.upper_bounds = np.full(self.D,  10.0)

    def get_limites(self):
        return self.lower_bounds, self.upper_bounds

    def evaluate(self, individuo):
        self.x = np.asarray(individuo, dtype=float)
        self.z = self.x - self.offset
        fitness = self.aptitud()
        suma_violaciones = self.sumar_violation()

        return fitness, suma_violaciones

    def aptitud(self):
        return np.sum((self.z[:-1] - self.z[1:]) ** 2)

    def g1(self):
        return np.prod(self.z)

    def g2(self):
        return np.sum(self.z)

    def h1(self):
        return np.sum(self.z * np.sin(4 * np.sqrt(np.abs(self.z))))

    def sumar_violation(self):
        viol_g1 = max(0.0, self.g1())
        viol_g2 = max(0.0, self.g2())
        viol_h1 = max(0.0, abs(self.h1()) - self.tolerance)
        return viol_g1 + viol_g2 + viol_h1

"""## C18"""

class ProblemaC18:
    def __init__(self,offset):
        self.tolerance = 1e-4
        self.offset = np.asarray(offset, dtype=float)
        self.D = len(self.offset)
        self.lower_bounds = np.full(self.D, -50.0)
        self.upper_bounds = np.full(self.D,  50.0)

    def get_limites(self):
        return self.lower_bounds, self.upper_bounds

    def evaluate(self, individuo):
        x = np.asarray(individuo, dtype=float)
        z = x - self.offset
        fitness = self.aptitud(z)
        suma_violaciones = self.sumar_violation(z)
        return fitness, suma_violaciones

    def aptitud(self, z):
        diffs = z[:-1] - z[1:]
        return np.sum(diffs**2)

    def g(self, z):
        return (1 / self.D) * np.sum(-z * np.sin(np.sqrt(np.abs(z))))

    def h(self, z):
        return (1 / self.D) * np.sum(z * np.sin(np.sqrt(np.abs(z))))

    def sumar_violation(self, z):
        h_val = self.h(z)
        g_val = self.g(z)
        viol_h = max(0.0, abs(h_val) - self.tolerance)
        viol_g = max(0.0, g_val)
        return viol_h + viol_g